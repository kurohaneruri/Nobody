# 实现计划: Nobody (修仙模拟器)

## 概述

本实现计划将 Nobody 修仙模拟器的设计转换为可执行的开发任务。项目采用 Tauri2 + Vue3 + TailwindCSS 技术栈，使用 Rust 实现后端逻辑，TypeScript/Vue3 实现前端界面。

实现分为三个主要阶段：
1. **第一阶段 (MVP)**: 基础框架、数值系统、简单剧本和存档
2. **第二阶段**: LLM 集成、智能 NPC、随机剧本生成
3. **第三阶段**: 小说生成、现有小说导入、UI 优化

每个阶段结束时都有检查点任务，确保代码质量和功能完整性。

## 任务列表

### 阶段 1: 项目初始化和基础框架

- [x] 1. 初始化项目结构
  - 使用 `create-tauri-app` 创建 Tauri2 + Vue3 项目
  - 配置 TypeScript 和 TailwindCSS
  - 设置项目目录结构（src-tauri/src, src/components, src/stores 等）
  - 配置 Rust 工具链和依赖（serde, tokio, anyhow 等）
  - 配置 Vue3 依赖（pinia, vue-router 等）
  - _需求: 8.1, 8.2, 8.3_

- [x] 2. 配置开发环境和工具
  - 配置 ESLint 和 Prettier（前端）
  - 配置 Clippy 和 Rustfmt（后端）
  - 设置 Git 仓库并连接到 https://github.com/MoSaSaPlus/Nobody
  - 创建 .gitignore 文件
  - 配置 CI/CD 基础（GitHub Actions）
  - _需求: 7.1, 7.2_

- [x] 3. Git 提交: 项目初始化
  - 提交信息: `chore: 初始化 Tauri2 + Vue3 项目及开发工具`
  - _需求: 7.3, 7.5_


### 阶段 2: 数值系统实现

- [x] 4. 实现核心数据模型
  - [x] 4.1 创建 Rust 数据结构
    - 在 `src-tauri/src/models.rs` 中定义 `CharacterStats`, `SpiritualRoot`, `CultivationRealm`, `Lifespan` 等结构体
    - 实现 Serialize/Deserialize traits
    - 添加必要的 derive 宏（Clone, Debug, PartialEq）
    - _需求: 2.1, 2.3_
  
  - [x] 4.2 编写数据模型的属性测试
    - **属性 26: 保存加载往返一致性**
    - 使用 proptest 生成任意数据模型实例
    - 验证序列化后反序列化能恢复原始数据
    - **验证需求: 9.3, 9.4**

- [x] 5. 实现数值系统核心逻辑
  - [x] 5.1 创建 NumericalSystem 模块
    - 在 `src-tauri/src/numerical_system.rs` 中实现 `NumericalSystem` 结构体
    - 实现 `calculate_action_result` 方法（基于角色属性和行动计算结果）
    - 实现 `validate_realm_breakthrough` 方法（验证境界突破的合理性）
    - 实现 `calculate_combat_outcome` 方法（计算战斗结果）
    - 实现 `update_lifespan` 方法（更新角色寿元）
    - _需求: 2.1, 2.4, 2.5, 2.6_
  
  - [x] 5.2 编写行动结果计算的属性测试
    - **属性 5: 行动结果数值一致性**
    - 验证相同输入产生相同输出
    - **验证需求: 2.4, 5.7**
  
  - [x] 5.3 编写境界提升的属性测试
    - **属性 6: 境界提升属性更新**
    - 验证境界提升后所有相关属性正确更新
    - **验证需求: 2.5**
  
  - [x] 5.4 编写寿元系统的属性测试
    - **属性 7: 寿元耗尽触发死亡**
    - 验证寿元为 0 时触发死亡事件
    - **验证需求: 2.6**
  
  - [x] 5.5 编写数值冲突解决的单元测试
    - 测试多个效果同时影响同一属性的情况
    - 验证优先级规则正确应用
    - _需求: 2.7_

- [x] 6. Git 提交: 数值系统实现
  - 提交信息: `feat(numerical): 实现核心数值系统和修仙机制`
  - _需求: 7.3, 7.5_

### 阶段 3: 剧本系统基础实现

- [x] 7. 实现剧本数据结构和验证
  - [x] 7.1 创建剧本相关数据模型
    - 在 `src-tauri/src/script.rs` 中定义 `Script`, `WorldSetting`, `ScriptType` 等结构体
    - 定义 `CultivationRealm`, `SpiritualRoot`, `Technique`, `Location`, `Faction` 等世界设定元素
    - 实现 JSON 序列化/反序列化
    - _需求: 1.2, 1.6_
  
  - [x] 7.2 实现剧本验证逻辑
    - 在 `ScriptManager` 中实现 `validate_script` 方法
    - 验证必要字段存在（世界设定、数值系统参数）
    - 验证数据格式正确性
    - _需求: 1.6, 1.7_
  
  - [x] 7.3 编写剧本验证的属性测试
    - **属性 3: 剧本验证一致性**
    - 生成缺少必要字段的剧本，验证被拒绝
    - **验证需求: 1.6, 1.7**

- [x] 8. 实现自定义剧本加载功能
  - [x] 8.1 实现 ScriptManager 的加载方法
    - 在 `src-tauri/src/script_manager.rs` 中实现 `load_custom_script` 方法
    - 读取 JSON 文件并解析为 Script 对象
    - 调用验证逻辑
    - 处理文件读取错误和解析错误
    - _需求: 1.5, 1.6_
  
  - [ ] 8.2 编写剧本加载的单元测试
    - 测试加载有效剧本文件
    - 测试加载无效剧本文件（格式错误、缺少字段）
    - 测试文件不存在的情况
    - _需求: 1.5, 1.7_
  
  - [ ]* 8.3 编写剧本类型支持的属性测试
    - **属性 1: 剧本类型支持完整性**
    - 验证系统能加载所有类型的剧本（当前仅自定义）
    - **验证需求: 1.2**

- [x] 9. Git 提交: 剧本系统基础
  - 提交信息: `feat(script): 实现剧本数据模型和自定义剧本加载`
  - _需求: 7.3, 7.5_


### 阶段 4: 游戏引擎和状态管理

- [x] 10. 实现游戏状态管理
  - [x] 10.1 创建游戏状态数据结构
    - 在 `src-tauri/src/game_state.rs` 中定义 `GameState`, `Character`, `WorldState`, `GameTime` 等结构体
    - 实现状态的序列化/反序列化
    - _需求: 9.1, 9.2_
  
  - [x] 10.2 实现游戏引擎核心
    - 在 `src-tauri/src/game_engine.rs` 中实现 `GameEngine` 结构体
    - 实现 `initialize_game` 方法（从剧本初始化游戏状态）
    - 实现 `get_current_state` 方法
    - 使用 Arc<Mutex<>> 管理共享状态
    - _需求: 1.1, 9.1_
  
  - [x] 10.3 编写游戏初始化的单元测试
    - 测试从有效剧本初始化游戏
    - 验证初始状态包含所有必要数据
    - _需求: 1.1, 1.6_

- [x] 11. 实现存档系统
  - [x] 11.1 创建 SaveLoadSystem 模块
    - 在 `src-tauri/src/save_load.rs` 中实现 `SaveLoadSystem` 结构体
    - 定义 `SaveData` 结构体（包含版本、时间戳、游戏状态）
    - 实现 `save_game` 方法（保存到 JSON 文件）
    - 实现 `load_game` 方法（从 JSON 文件加载）
    - 实现 `validate_save_data` 方法（验证版本兼容性和完整性）
    - 支持多个存档槽位（slot_id）
    - _需求: 9.1, 9.2, 9.5, 9.7_
  
  - [x] 11.2 编写存档保存的属性测试
    - **属性 24: 游戏状态保存能力**
    - 验证任何有效游戏状态都能成功保存
    - **验证需求: 9.1**
  
  - [x] 11.3 编写存档加载的属性测试
    - **属性 25: 存档加载能力**
    - 验证任何有效存档都能成功加载
    - **验证需求: 9.2**
  
  - [x] 11.4 编写存档往返的属性测试
    - **属性 26: 保存加载往返一致性**
    - 验证保存后加载恢复相同状态
    - **验证需求: 9.3, 9.4**
  
  - [x] 11.5 编写存档验证的属性测试
    - **属性 27: 存档验证保护**
    - 验证损坏或不兼容的存档被拒绝
    - **验证需求: 9.5, 9.6**
  
  - [x] 11.6 编写多存档槽位的属性测试
    - **属性 28: 多存档槽位隔离**
    - 验证不同槽位的数据相互独立
    - **验证需求: 9.7**

- [x] 12. 集成存档系统到游戏引擎
  - [x] 12.1 在 GameEngine 中添加存档方法
    - 实现 `save_game` 方法（调用 SaveLoadSystem）
    - 实现 `load_game` 方法（调用 SaveLoadSystem 并恢复状态）
    - _需求: 9.1, 9.2_
  
  - [x]* 12.2 编写集成测试
    - 测试完整的保存-加载流程
    - 测试加载后游戏能继续运行
    - _需求: 9.3, 9.4_

- [x] 13. Git 提交: 游戏引擎和存档系统
  - 提交信息: `feat(engine): 实现游戏引擎和存档系统`
  - _需求: 7.3, 7.5_

### 阶段 5: 基础剧情引擎（选项式交互）

- [x] 14. 实现剧情状态和场景管理
  - [x] 14.1 创建剧情相关数据结构
    - 在 `src-tauri/src/plot_engine.rs` 中定义 `PlotState`, `Scene`, `PlayerOption`, `PlayerAction` 等结构体
    - 定义 `ActionType` 枚举（FreeText, SelectedOption）
    - _需求: 5.2, 5.3_
  
  - [x] 14.2 实现 PlotEngine 基础功能
    - 实现 `PlotEngine` 结构体
    - 实现 `advance_plot` 方法（根据行动结果推进剧情）
    - 实现场景切换逻辑
    - _需求: 5.2, 5.7_
  
  - [x] 14.3 编写剧情暂停的属性测试
    - **属性 18: 剧情决策点暂停**
    - 验证需要决策时剧情正确暂停
    - **验证需求: 5.2**

- [x] 15. 实现选项生成功能（硬编码版本）
  - [x] 15.1 实现静态选项生成
    - 在 `PlotEngine` 中实现 `generate_player_options` 方法
    - 根据当前场景生成 2-5 个预定义选项
    - 每个选项包含描述和可选的需求条件
    - _需求: 5.3, 5.4_
  
  - [x]* 15.2 编写选项数量的属性测试
    - **属性 19: 选项数量约束**
    - 验证生成的选项数量在 2-5 之间
    - **验证需求: 5.4**
  
  - [x]* 15.3 编写选项生成的单元测试
    - 测试不同场景生成合适的选项
    - 测试选项包含必要信息
    - _需求: 5.4_

- [x] 16. 实现玩家行动处理
  - [x] 16.1 实现行动验证和处理
    - 在 `PlotEngine` 中实现 `validate_player_action` 方法
    - 实现 `process_player_action` 方法（当前仅处理选项选择）
    - 调用 `NumericalSystem` 计算行动结果
    - 生成 `PlotUpdate`（新状态、触发事件）
    - _需求: 5.7, 5.8_
  
  - [x]* 16.2 编写行动处理的单元测试
    - 测试有效选项被正确处理
    - 测试无效选项被拒绝
    - 测试行动结果正确计算
    - _需求: 5.6, 5.7_

- [x] 17. Git 提交: 基础剧情引擎
  - 提交信息: `feat(plot): 实现基础剧情引擎和选项式交互`
  - _需求: 7.3, 7.5_


### 阶段 6: Tauri API 层

- [x] 18. 实现 Tauri 命令接口
  - [x] 18.1 创建 Tauri 命令
    - 在 `src-tauri/src/tauri_commands.rs` 中实现所有 Tauri 命令
    - `initialize_game`: 初始化游戏
    - `execute_player_action`: 执行玩家行动
    - `get_game_state`: 获取当前游戏状态
    - `save_game`: 保存游戏
    - `load_game`: 加载游戏
    - `load_script`: 加载剧本
    - `get_player_options`: 获取玩家选项
    - 使用 `tauri::State` 管理 GameEngine 实例
    - _需求: 1.1, 5.2, 9.1, 9.2_
  
  - [x] 18.2 配置 Tauri 应用
    - 在 `src-tauri/src/main.rs` 中注册所有命令
    - 初始化 GameEngine 状态
    - 配置窗口属性
    - _需求: 8.1_
  
  - [x]* 18.3 编写 Tauri 命令的集成测试
    - 测试命令能正确调用后端逻辑
    - 测试错误处理和返回值
    - _需求: 1.1, 9.1, 9.2_

- [x] 19. Git 提交: Tauri API 层
  - 提交信息: `feat(tauri): 实现 Tauri 命令接口用于前后端通信`
  - _需求: 7.3, 7.5_

### 阶段 7: 前端基础框架

- [x] 20. 设置前端状态管理
  - [x] 20.1 创建 Pinia Store
    - 在 `src/stores/gameStore.ts` 中创建 `useGameStore`
    - 定义状态：currentScript, playerCharacter, npcs, currentPlot, gameHistory
    - 实现 actions：initializeGame, executePlayerAction, saveGame, loadGame
    - 使用 Tauri invoke 调用后端命令
    - _需求: 1.1, 5.2, 9.1, 9.2_
  
  - [ ]* 20.2 编写 Store 的单元测试
    - 使用 Vitest 测试 Store actions
    - Mock Tauri invoke 调用
    - 验证状态正确更新
    - _需求: 1.1, 9.1_

- [x] 21. 实现主菜单组件
  - [x] 21.1 创建 MainMenu.vue 组件
    - 在 `src/components/MainMenu.vue` 中实现主菜单
    - 提供"新游戏"、"加载游戏"、"设置"按钮
    - 使用 TailwindCSS 样式
    - _需求: 1.1, 8.3_
  
  - [ ]* 21.2 编写主菜单的单元测试
    - 使用 Vue Test Utils 测试组件渲染
    - 测试按钮点击事件
    - _需求: 1.1_

- [x] 22. 实现剧本选择器组件
  - [x] 22.1 创建 ScriptSelector.vue 组件
    - 在 `src/components/ScriptSelector.vue` 中实现剧本选择器
    - 显示三种剧本类型（当前仅自定义可用）
    - 提供文件选择对话框（使用 Tauri dialog API）
    - 调用 Store 的 initializeGame 方法
    - _需求: 1.1, 1.2, 1.5_
  
  - [ ]* 22.2 编写剧本选择器的单元测试
    - 测试组件渲染
    - 测试文件选择和剧本加载
    - _需求: 1.1, 1.5_

- [x] 23. Git 提交: 前端基础框架
  - 提交信息: `feat(frontend): 实现 Pinia 状态管理和主菜单组件`
  - _需求: 7.3, 7.5_


### 阶段 8: 游戏主界面

- [x] 24. 实现游戏视图组件
  - [x] 24.1 创建 GameView.vue 组件
    - 在 `src/components/GameView.vue` 中实现游戏主视图
    - 显示剧情文本（使用滚动容器）
    - 显示玩家选项（按钮列表）
    - 处理玩家选择并调用 Store
    - 显示加载状态和等待输入状态
    - _需求: 5.1, 5.2, 5.3, 8.7_
  
  - [ ]* 24.2 编写游戏视图的单元测试
    - 测试剧情文本正确显示
    - 测试选项列表正确渲染
    - 测试玩家选择处理
    - _需求: 5.2, 5.3_
  
  - [ ]* 24.3 编写长文本滚动的测试
    - 测试长文本时滚动功能存在
    - **验证需求: 8.7**

- [x] 25. 实现角色信息面板
  - [x] 25.1 创建 CharacterPanel.vue 组件
    - 在 `src/components/CharacterPanel.vue` 中实现角色面板
    - 显示角色名称、境界、灵根、寿元等信息
    - 实时更新角色状态
    - 使用 TailwindCSS 美化样式
    - _需求: 2.1, 2.3, 8.3_
  
  - [ ]* 25.2 编写角色面板的单元测试
    - 测试角色信息正确显示
    - 测试状态更新
    - _需求: 2.3_

- [x] 26. 实现存档管理界面
  - [x] 26.1 创建 SaveLoadDialog.vue 组件
    - 在 `src/components/SaveLoadDialog.vue` 中实现存档对话框
    - 显示多个存档槽位
    - 提供保存和加载按钮
    - 显示存档信息（时间戳、角色名称等）
    - 调用 Store 的 saveGame 和 loadGame 方法
    - _需求: 9.1, 9.2, 9.7_
  
  - [ ]* 26.2 编写存档界面的单元测试
    - 测试存档列表显示
    - 测试保存和加载操作
    - _需求: 9.1, 9.2, 9.7_

- [x] 27. 实现路由和页面切换
  - [x] 27.1 配置 Vue Router
    - 在 `src/router/index.ts` 中配置路由
    - 路由：/ (主菜单), /script-select (剧本选择), /game (游戏界面)
    - 实现页面切换逻辑
    - _需求: 1.1, 5.2_
  
  - [ ]* 27.2 编写路由的单元测试
    - 测试路由导航
    - 测试页面组件正确加载
    - _需求: 1.1_

- [x] 28. Git 提交: 游戏主界面
  - 提交信息: `feat(frontend): 实现游戏视图、角色面板和存档界面`
  - _需求: 7.3, 7.5_

### 阶段 9: MVP 检查点

- [x] 29. MVP 功能测试和修复
  - 运行所有单元测试和属性测试，确保通过
  - 手动测试完整游戏流程：启动 -> 选择剧本 -> 游戏 -> 保存 -> 加载
  - 修复发现的 bug
  - 优化用户体验
  - 确保所有测试通过，询问用户是否有问题

- [x] 30. Git 提交: MVP 完成
  - 提交信息: `chore: 完成 MVP，包含基础游戏玩法和存档功能`
  - 创建 Git tag: `v0.1.0`
  - _需求: 7.3, 7.5_


### 阶段 10: LLM 服务集成

- [x] 31. 实现 LLM 服务基础设施
  - [x] 31.1 创建 LLM 配置和客户端
    - 在 `src-tauri/src/llm_service.rs` 中实现 `LLMService` 结构体
    - 定义 `LLMConfig` 结构体（endpoint, api_key, model, max_tokens, temperature）
    - 实现 HTTP 客户端（使用 reqwest）
    - 实现 `generate` 方法（调用 LLM API）
    - 实现基本的错误处理和超时
    - _需求: 10.1, 10.2, 10.3_
  
  - [x] 31.2 编写 LLM 调用失败的属性测试
    - **属性 30: LLM 调用失败容错**
    - Mock API 失败，验证系统优雅处理
    - **验证需求: 10.3**
  
  - [x] 31.3 编写 LLM 配置的单元测试
    - 测试配置加载和验证
    - **验证需求: 10.1**

- [x] 32. 实现提示词构建器
  - [x] 32.1 创建 PromptBuilder 模块
    - 在 `src-tauri/src/prompt_builder.rs` 中实现 `PromptBuilder`
    - 实现 `build_prompt` 方法（根据模板和上下文构建提示词）
    - 定义提示词模板（剧本生成、选项生成、NPC 决策等）
    - 实现上下文注入（场景、角色状态、历史事件）
    - 实现约束注入（数值系统规则、世界设定）
    - _需求: 10.2_
  
  - [x]* 32.2 编写提示词构建的属性测试
    - **属性 29: LLM 提示词上下文完整性**
    - 验证提示词包含必要的上下文和约束
    - **验证需求: 10.2**

- [x] 33. 实现响应验证器
  - [] 33.1 创建 ResponseValidator 模块
    - 在 `src-tauri/src/response_validator.rs` 中实现 `ResponseValidator`
    - 实现 `validate_response` 方法（验证响应格式和内容）
    - 实现数值系统约束验证
    - 实现 JSON 格式验证
    - _需求: 10.4, 10.7_
  
  - [x]* 33.2 编写响应验证的属性测试
    - **属性 4: LLM 输出数值约束**
    - 验证 LLM 生成内容符合数值系统规则
    - **验证需求: 2.2, 10.7**
  
  - [x]* 33.3 编写响应验证重试的属性测试
    - **属性 31: LLM 响应验证重试**
    - 验证无效响应触发重试或后备方案
    - **验证需求: 10.4**

- [x] 34. 实现响应缓存
  - [x] 34.1 创建缓存系统
    - 在 `LLMService` 中实现 `ResponseCache`
    - 使用 HashMap 存储缓存（请求哈希 -> 响应）
    - 实现 `cache_response` 和 `get_cached_response` 方法
    - 实现缓存过期策略（LRU 或时间过期）
    - _需求: 10.5_
  
  - [x]* 34.2 编写缓存的属性测试
    - **属性 32: LLM 响应缓存命中**
    - 验证相同请求返回缓存响应
    - **验证需求: 10.5**

- [x] 35. 实现 Token 限制
  - [x] 35.1 添加 Token 计数和限制
    - 在 `PromptBuilder` 中实现 Token 计数（简单的字符/单词估算）
    - 在 `LLMService` 中验证请求不超过限制
    - 实现提示词截断策略（保留重要部分）
    - _需求: 10.6_
  
  - [x]* 35.2 编写 Token 限制的属性测试
    - **属性 33: LLM Token 限制遵守**
    - 验证所有请求不超过 token 限制
    - **验证需求: 10.6**

- [x] 36. Git 提交: LLM 服务集成
  - 提交信息: `feat(llm): 实现 LLM 服务，包含提示词构建、验证和缓存`
  - _需求: 7.3, 7.5_


### 阶段 11: 随机剧本生成

- [x] 37. 实现随机剧本生成功能
  - [x] 37.1 在 ScriptManager 中添加随机生成方法
    - 实现 `generate_random_script` 方法
    - 使用 LLM 生成世界设定（修仙境界、灵根类型、功法、地点、门派）
    - 构建包含数值系统约束的提示词
    - 解析 LLM 响应并构建 Script 对象
    - 验证生成的剧本完整性
    - _需求: 1.4_
  
  - [x]* 37.2 编写随机剧本生成的属性测试
    - **属性 2: 随机剧本生成完整性**
    - 验证生成的剧本包含所有必要元素
    - **验证需求: 1.4**
  
  - [x]* 37.3 编写随机剧本生成的单元测试
    - 测试生成的剧本格式正确
    - 测试生成失败时的错误处理
    - _需求: 1.4_

- [x] 38. 更新前端支持随机剧本
  - [x] 38.1 更新 ScriptSelector 组件
    - 添加"随机生成"选项
    - 显示生成进度（加载指示器）
    - 处理生成失败的情况
    - _需求: 1.4_
  
  - [ ]* 38.2 编写前端随机剧本的单元测试
    - 测试随机生成按钮功能
    - 测试加载状态显示
    - _需求: 1.4_

- [x] 39. Git 提交: 随机剧本生成
  - 提交信息: `feat(script): 实现基于 LLM 的随机剧本生成`
  - _需求: 7.3, 7.5_

### 阶段 12: 智能 NPC 系统

- [x] 40. 实现 NPC 数据结构和记忆系统
  - [x] 40.1 创建 NPC 相关数据模型
    - 在 `src-tauri/src/npc.rs` 中定义 `NPC`, `Personality`, `NPCMemory`, `Relationship` 等结构体
    - 定义 `MemoryEntry` 结构体（时间戳、事件、重要性、情感影响）
    - 实现序列化/反序列化
    - _需求: 4.2, 4.7_
  
  - [x] 40.2 实现记忆管理器
    - 在 `src-tauri/src/memory_manager.rs` 中实现 `MemoryManager`
    - 实现 `add_memory` 方法（添加记忆条目）
    - 实现 `compress_memories` 方法（基于重要性压缩旧记忆）
    - 实现记忆检索方法（根据相关性查询记忆）
    - _需求: 4.7, 4.8_
  
  - [x]* 40.3 编写记忆持久化的属性测试
    - **属性 16: NPC 记忆持久化**
    - 验证重要事件被添加到 NPC 记忆
    - **验证需求: 4.7**
  
  - [x]* 40.4 编写记忆压缩的属性测试
    - **属性 17: NPC 记忆压缩保真**
    - 验证记忆超限时正确压缩而不丢失关键信息
    - **验证需求: 4.8**

- [x] 41. 实现 NPC 引擎核心
  - [x] 41.1 创建 NPCEngine 模块
    - 在 `src-tauri/src/npc_engine.rs` 中实现 `NPCEngine` 结构体
    - 实现 `process_event` 方法（处理游戏事件并生成 NPC 反应）
    - 实现 `update_npc_memory` 方法（更新 NPC 记忆）
    - 实现 `update_relationship` 方法（更新人际关系）
    - _需求: 4.3, 4.4, 4.7_
  
  - [x]* 41.2 编写 NPC 事件响应的属性测试
    - **属性 13: NPC 事件响应生成**
    - 验证 NPC 对事件生成决策
    - **验证需求: 4.3**
  
  - [x]* 41.3 编写关系更新的属性测试
    - **属性 14: 互动更新关系**
    - 验证互动更新人际关系数据
    - **验证需求: 4.4**

- [x] 42. 实现 NPC 决策生成
  - [x] 42.1 实现基于 LLM 的 NPC 决策
    - 在 `NPCEngine` 中实现 `generate_npc_decision` 方法
    - 构建包含 NPC 性格、记忆、关系的提示词
    - 调用 LLM 生成决策
    - 验证决策符合数值系统约束
    - _需求: 4.3, 4.6_
  
  - [x]* 42.2 编写 NPC 决策验证的单元测试
    - 测试决策符合 NPC 性格
    - 测试决策符合数值约束
    - _需求: 4.6_

- [x] 43. 实现 NPC 自主行动
  - [x] 43.1 添加自主行动系统
    - 在 `NPCEngine` 中实现 `autonomous_npc_actions` 方法
    - 定期检查 NPC 目标和环境
    - 生成自主行动（不依赖玩家输入）
    - _需求: 4.5_
  
  - [x]* 43.2 编写自主行动的属性测试
    - **属性 15: NPC 自主行动能力**
    - 验证 NPC 能在无玩家输入时自主行动
    - **验证需求: 4.5**

- [x] 44. 集成 NPC 系统到游戏引擎
  - [x] 44.1 在 GameEngine 中集成 NPCEngine
    - 在游戏初始化时创建 NPC
    - 在剧情推进时调用 NPC 引擎
    - 在事件发生时更新 NPC 状态
    - _需求: 4.1, 4.3, 5.8_
  
  - [x]* 44.2 编写 NPC 集成的测试
    - 测试剧情发展触发 NPC 反应
    - **属性 22: 剧情发展触发 NPC 反应**
    - **验证需求: 5.8**

- [x] 45. Git 提交: 智能 NPC 系统
  - 提交信息: `feat(npc): 实现智能 NPC 系统和 LLM 驱动的决策机制`
  - _需求: 7.3, 7.5_


### 阶段 13: 自由文本输入和智能剧情

- [x] 46. 实现自由文本输入解析
  - [x] 46.1 在 PlotEngine 中添加文本解析
    - 更新 `process_player_action` 方法支持自由文本
    - 使用 LLM 解析玩家意图
    - 将意图转换为游戏内行动
    - _需求: 5.5_
  
  - [x]* 46.2 编写自由文本解析的属性测试
    - **属性 20: 自由文本意图解析**
    - 验证任何文本输入都能被解析
    - **验证需求: 5.5**

- [x] 47. 实现行为合理性验证
  - [x] 47.1 添加行为验证逻辑
    - 在 `validate_player_action` 中添加合理性检查
    - 使用 LLM 判断行为是否符合场景和角色能力
    - 拒绝不合理行为并提示玩家
    - _需求: 5.6_
  
  - [x]* 47.2 编写行为验证的属性测试
    - **属性 21: 不合理行为拒绝**
    - 验证不合理输入被拒绝
    - **验证需求: 5.6**

- [x] 48. 实现 LLM 驱动的剧情生成
  - [x] 48.1 更新剧情文本生成
    - 在 `PlotEngine` 中实现 `generate_plot_text` 方法
    - 使用 LLM 生成小说风格的剧情文本
    - 基于场景、事件和 NPC 反应生成内容
    - _需求: 5.1_
  
  - [x]* 48.2 编写剧情生成的单元测试
    - 测试剧情文本包含必要信息
    - 测试文本风格符合要求
    - _需求: 5.1_

- [x] 49. 更新前端支持自由文本输入
  - [x] 49.1 更新 GameView 组件
    - 添加文本输入框
    - 支持两种输入模式切换（选项/自由文本）
    - 显示输入验证反馈
    - _需求: 5.3, 5.5, 5.6_
  
  - [x]* 49.2 编写前端输入的单元测试
    - 测试输入模式切换
    - 测试文本输入提交
    - _需求: 5.3, 5.5_

- [x] 50. Git 提交: 自由文本输入和智能剧情
  - 提交信息: `feat(plot): 实现自由文本输入解析和 LLM 驱动的剧情生成`
  - _需求: 7.3, 7.5_

### 阶段 14: 第二阶段检查点

- [x] 51. 第二阶段功能测试和修复
  - 运行所有单元测试和属性测试，确保通过
  - 手动测试 LLM 集成功能：随机剧本生成、NPC 互动、自由文本输入
  - 测试 NPC 自主行动和记忆系统
  - 修复发现的 bug
  - 优化 LLM 调用性能和成本
  - 确保所有测试通过，询问用户是否有问题

- [x] 52. Git 提交: 第二阶段完成
  - 提交信息: `chore: 完成第二阶段，包含 LLM 集成和智能 NPC 系统`
  - 创建 Git tag: `v0.2.0`
  - _需求: 7.3, 7.5_


### 阶段 15: 小说生成功能

- [x] 53. 实现事件日志系统
  - [x] 53.1 创建事件日志模块
    - 在 `src-tauri/src/event_log.rs` 中实现 `EventLog` 结构体
    - 实现 `log_event` 方法（记录游戏事件）
    - 实现事件分类（重要/普通）
    - 实现事件查询和过滤
    - _需求: 3.1_
  
  - [x]* 53.2 编写事件记录的属性测试
    - **属性 9: 事件记录完整性**
    - 验证所有重要事件被记录
    - **验证需求: 3.1**

- [x] 54. 集成事件日志到游戏引擎
  - [x] 54.1 在 GameEngine 中添加事件记录
    - 在所有关键操作中调用 EventLog
    - 记录战斗、突破、死亡、重要对话等事件
    - 在存档中包含事件历史
    - _需求: 3.1, 9.3_
  
  - [x]* 54.2 编写事件日志集成的单元测试
    - 测试事件正确记录
    - 测试事件包含必要信息
    - _需求: 3.1_

- [x] 55. 实现小说生成器
  - [x] 55.1 创建 NovelGenerator 模块
    - 在 `src-tauri/src/novel_generator.rs` 中实现 `NovelGenerator` 结构体
    - 定义 `Novel` 和 `Chapter` 数据结构
    - 实现 `generate_novel` 方法（从事件历史生成小说）
    - 实现 `generate_chapter` 方法（生成单个章节）
    - 使用 LLM 将事件转换为文学化文本
    - _需求: 3.3, 3.4_
  
  - [x]* 55.2 编写小说生成的属性测试
    - **属性 10: 小说生成可用性**
    - 验证任何游戏历史都能生成小说
    - **验证需求: 3.3, 3.4**
  
  - [x]* 55.3 编写小说时序的属性测试
    - **属性 12: 小说事件时序保持**
    - 验证小说中事件按时间顺序排列
    - **验证需求: 3.6**

- [x] 56. 实现小说导出功能
  - [x] 56.1 添加小说导出方法
    - 在 `NovelGenerator` 中实现 `export_to_file` 方法
    - 支持导出为 TXT 格式
    - 格式化章节和段落
    - _需求: 3.5_
  
  - [x]* 56.2 编写小说导出的属性测试
    - **属性 11: 小说导出功能**
    - 验证任何小说都能导出为文件
    - **验证需求: 3.5**

- [x] 57. 添加小说生成 Tauri 命令
  - [x] 57.1 在 tauri_commands.rs 中添加命令
    - 实现 `generate_novel` 命令
    - 实现 `export_novel` 命令
    - 处理生成进度和错误
    - _需求: 3.2, 3.3, 3.5_
  
  - [x]* 57.2 编写命令的集成测试
    - 测试小说生成命令
    - 测试导出命令
    - _需求: 3.3, 3.5_

- [x] 58. 实现小说导出界面
  - [x] 58.1 创建 NovelExporter.vue 组件
    - 在 `src/components/NovelExporter.vue` 中实现小说导出器
    - 在游戏结束时显示（通关或死亡）
    - 显示生成进度
    - 提供预览和导出按钮
    - _需求: 3.2, 3.5_
  
  - [x]* 58.2 编写小说导出界面的单元测试
    - 测试组件在游戏结束时显示
    - 测试导出功能
    - _需求: 3.2, 3.5_

- [x] 59. Git 提交: 小说生成功能
  - 提交信息: `feat(novel): 实现从游戏历史生成小说的功能`
  - _需求: 7.3, 7.5_

### 阶段 16: 现有小说剧本导入

- [x] 60. 实现小说解析器
  - [x] 60.1 创建小说解析模块
    - 在 `src-tauri/src/novel_parser.rs` 中实现 `NovelParser`
    - 实现文本分析（识别角色、地点、事件）
    - 使用 LLM 提取世界设定和角色信息
    - 生成剧本数据结构
    - _需求: 1.3_
  
  - [x]* 60.2 编写小说解析的单元测试
    - 测试解析有效小说文件
    - 测试提取角色和世界设定
    - _需求: 1.3_

- [ ] 61. 实现角色选择功能
  - [ ] 61.1 在 ScriptManager 中添加角色选择
    - 更新 `load_existing_novel` 方法
    - 解析小说并提取角色列表
    - 根据选择的角色生成初始状态
    - _需求: 1.3_
  
  - [ ]* 61.2 编写角色选择的单元测试
    - 测试角色列表提取
    - 测试角色初始状态生成
    - _需求: 1.3_

- [ ] 62. 更新前端支持小说导入
  - [ ] 62.1 更新 ScriptSelector 组件
    - 添加"现有小说"选项
    - 提供文件选择和角色选择界面
    - 显示解析进度
    - _需求: 1.3_
  
  - [ ]* 62.2 编写前端小说导入的单元测试
    - 测试文件选择功能
    - 测试角色选择界面
    - _需求: 1.3_

- [ ] 63. Git 提交: 现有小说剧本导入
  - 提交信息: `feat(script): 实现现有小说导入和角色选择功能`
  - _需求: 7.3, 7.5_


### 阶段 17: UI 优化和美化

- [ ] 64. 优化界面响应性
  - [ ] 64.1 实现加载状态指示器
    - 在所有异步操作中显示加载动画
    - 使用 TailwindCSS 创建美观的加载组件
    - 添加操作进度提示
    - _需求: 8.5_
  
  - [ ]* 64.2 编写响应性的测试
    - 测试加载状态正确显示
    - 测试操作完成后状态清除
    - _需求: 8.5_

- [ ] 65. 实现窗口响应式布局
  - [ ] 65.1 优化布局适配
    - 使用 TailwindCSS 响应式类
    - 测试不同窗口大小下的布局
    - 确保所有元素可访问
    - _需求: 8.6_
  
  - [ ]* 65.2 编写布局响应的属性测试
    - **属性 23: 窗口调整布局保持**
    - 验证窗口调整不破坏布局
    - **验证需求: 8.6**

- [ ] 66. 美化 UI 设计
  - [ ] 66.1 设计统一的视觉风格
    - 选择配色方案（修仙主题）
    - 设计按钮、卡片、面板样式
    - 添加过渡动画和悬停效果
    - 优化字体和排版
    - _需求: 8.3_
  
  - [ ] 66.2 优化游戏文本显示
    - 改进剧情文本的排版和可读性
    - 添加文本渐显效果
    - 优化滚动体验
    - _需求: 5.1, 8.7_

- [ ] 67. 添加音效和背景音乐（可选）
  - [ ] 67.1 集成音频系统
    - 添加背景音乐播放
    - 添加 UI 交互音效
    - 提供音量控制
    - _需求: 8.3_

- [ ] 68. Git 提交: UI 优化和美化
  - 提交信息: `feat(ui): 优化界面响应性和视觉设计`
  - _需求: 7.3, 7.5_

### 阶段 18: 性能优化

- [ ] 69. 优化 LLM 调用性能
  - [ ] 69.1 实现请求批处理
    - 合并多个 NPC 决策请求
    - 减少 API 调用次数
    - _需求: 10.5_
  
  - [ ] 69.2 优化缓存策略
    - 增加缓存容量
    - 实现智能缓存预热
    - 优化缓存命中率
    - _需求: 10.5_
  
  - [ ]* 69.3 编写性能测试
    - 测试缓存命中率
    - 测试批处理效果
    - _需求: 10.5_

- [ ] 70. 优化内存使用
  - [ ] 70.1 实现数据分层存储
    - NPC 记忆分短期/长期存储
    - 事件历史定期归档
    - 使用引用计数减少复制
    - _需求: 4.8_
  
  - [ ]* 70.2 编写内存优化测试
    - 测试长时间运行不会内存泄漏
    - 测试记忆压缩正确工作
    - _需求: 4.8_

- [ ] 71. 优化前端性能
  - [ ] 71.1 实现虚拟滚动
    - 对长文本使用虚拟滚动
    - 优化大量 NPC 显示
    - _需求: 8.7_
  
  - [ ] 71.2 优化组件渲染
    - 使用 Vue3 的 Composition API 优化
    - 添加必要的 memo 和 computed
    - 减少不必要的重渲染
    - _需求: 8.4_

- [ ] 72. Git 提交: 性能优化
  - 提交信息: `perf: 优化 LLM 调用、内存使用和前端渲染`
  - _需求: 7.3, 7.5_

### 阶段 19: 错误处理和健壮性

- [ ] 73. 完善错误处理
  - [ ] 73.1 统一错误处理机制
    - 在所有模块中实现一致的错误类型
    - 添加详细的错误信息
    - 实现错误日志记录
    - _需求: 10.3_
  
  - [ ] 73.2 实现错误恢复机制
    - 添加状态回滚功能
    - 实现自动重试策略
    - 提供用户友好的错误提示
    - _需求: 10.3, 10.4_
  
  - [ ]* 73.3 编写错误处理的单元测试
    - 测试各种错误场景
    - 测试错误恢复机制
    - _需求: 10.3, 10.4_

- [ ] 74. 添加输入验证
  - [ ] 74.1 完善所有输入验证
    - 验证用户输入的合法性
    - 验证文件格式和内容
    - 防止注入攻击
    - _需求: 1.6, 1.7, 5.6_
  
  - [ ]* 74.2 编写输入验证的测试
    - 测试各种非法输入
    - 测试边界条件
    - _需求: 1.7, 5.6_

- [ ] 75. Git 提交: 错误处理和健壮性
  - 提交信息: `fix: 改进错误处理和输入验证`
  - _需求: 7.3, 7.5_


### 阶段 20: 测试完善和文档

- [ ] 76. 完善测试覆盖
  - [ ] 76.1 补充缺失的单元测试
    - 确保核心模块达到 90% 覆盖率
    - 确保数值系统达到 100% 覆盖率
    - 添加边缘案例测试
    - _需求: 2.1, 2.4, 2.5, 2.6_
  
  - [ ] 76.2 补充缺失的属性测试
    - 确保所有正确性属性都有对应测试
    - 每个测试运行至少 100 次迭代
    - _需求: 所有需求_
  
  - [ ]* 76.3 运行完整测试套件
    - 运行所有单元测试
    - 运行所有属性测试
    - 生成测试覆盖率报告
    - 修复失败的测试

- [ ] 77. 编写用户文档
  - [ ] 77.1 创建用户手册
    - 编写安装指南
    - 编写使用教程
    - 编写功能说明
    - 添加常见问题解答
  
  - [ ] 77.2 创建示例剧本
    - 创建 2-3 个示例自定义剧本
    - 提供剧本编写指南
    - 说明剧本格式和要求
    - _需求: 1.5, 1.6_

- [ ] 78. 编写开发者文档
  - [ ] 78.1 创建 API 文档
    - 文档化所有 Tauri 命令
    - 文档化数据结构
    - 添加代码示例
  
  - [ ] 78.2 创建架构文档
    - 说明系统架构
    - 说明模块职责
    - 添加架构图
  
  - [ ] 78.3 创建贡献指南
    - 说明开发环境设置
    - 说明代码规范
    - 说明提交流程

- [ ] 79. Git 提交: 测试和文档完善
  - 提交信息: `docs: 添加完整的用户和开发者文档`
  - _需求: 7.3, 7.5_

### 阶段 21: 第三阶段检查点和发布准备

- [ ] 80. 第三阶段功能测试
  - 运行所有单元测试和属性测试，确保通过
  - 手动测试所有功能：剧本系统、游戏流程、NPC 互动、小说生成
  - 测试 UI 在不同窗口大小下的表现
  - 测试性能和内存使用
  - 修复发现的 bug
  - 确保所有测试通过，询问用户是否有问题

- [ ] 81. 准备发布版本
  - [ ] 81.1 配置生产构建
    - 优化 Tauri 构建配置
    - 配置应用图标和元数据
    - 生成安装包（Windows/macOS/Linux）
  
  - [ ] 81.2 创建发布说明
    - 编写 CHANGELOG.md
    - 列出所有功能和改进
    - 列出已知问题和限制
  
  - [ ] 81.3 准备发布资源
    - 准备应用截图
    - 准备宣传材料
    - 准备示例剧本文件

- [ ] 82. Git 提交: 发布准备
  - 提交信息: `chore: 准备 v1.0.0 正式版本发布`
  - 创建 Git tag: `v1.0.0`
  - _需求: 7.3, 7.5_

### 阶段 22: 最终检查点

- [ ] 83. 最终验收测试
  - 完整测试所有功能模块
  - 验证所有需求都已实现
  - 验证所有正确性属性都有测试
  - 验证文档完整准确
  - 验证构建和安装流程
  - 确保所有测试通过，询问用户是否有问题

## 注意事项

### 任务标记说明

- `[ ]`: 未完成的任务
- `[ ]*`: 可选的测试任务（可以跳过以加快 MVP 开发）
- 所有非测试任务都必须完成
- 测试任务虽然标记为可选，但强烈建议完成以确保代码质量

### Git 提交策略

- 每个主要阶段完成后都有 Git 提交任务
- 提交信息遵循 Conventional Commits 格式
- 重要里程碑创建 Git tag（v0.1.0, v0.2.0, v1.0.0）

### 开发优先级

1. **第一阶段 (任务 1-30)**: MVP 核心功能，必须完成
2. **第二阶段 (任务 31-52)**: LLM 集成和智能功能，核心价值
3. **第三阶段 (任务 53-83)**: 完善功能和优化，提升体验

### 测试要求

- 属性测试使用 `proptest` (Rust) 和 `fast-check` (TypeScript)
- 每个属性测试至少运行 100 次迭代
- 每个测试必须引用对应的设计文档属性
- 测试标签格式: `Feature: Nobody, Property {number}: {property_text}`

### 依赖关系

- 任务按顺序设计，后续任务依赖前面任务的完成
- 可以并行开发独立的模块（如前端和后端）
- 测试任务可以在实现任务完成后立即进行

### 检查点说明

检查点任务（29, 51, 80, 83）的目的是：
1. 确保所有测试通过
2. 手动验证功能完整性
3. 修复发现的问题
4. 向用户确认是否继续

在检查点处，如果发现问题，应该返回修复相关任务，而不是继续前进。

